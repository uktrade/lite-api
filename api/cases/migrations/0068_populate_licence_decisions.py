# Generated by Django 4.2.16 on 2024-10-29 14:32
import datetime

from django.db import migrations, transaction
from django.db.models import (
    Case as DBCase,
    Value,
    When,
)

from api.audit_trail.enums import AuditType
from api.cases.enums import AdviceType
from api.staticdata.statuses.enums import CaseStatusEnum


SIEL_LICENCE_TEMPLATE_ID = "d159b195-9256-4a00-9bc8-1eb2cebfa1d2"
SIEL_REFUSAL_TEMPLATE_ID = "074d8a54-ee10-4dca-82ba-650460650342"


class LicenceDecisionType:
    ISSUED = "issued"
    REFUSED = "refused"

    choices = [
        (ISSUED, "issued"),
        (REFUSED, "refused"),
    ]

    decision_map = {
        AdviceType.APPROVE: ISSUED,
        AdviceType.REFUSE: REFUSED,
    }

    @classmethod
    def templates(cls):
        return {
            cls.ISSUED: SIEL_LICENCE_TEMPLATE_ID,
            cls.REFUSED: SIEL_REFUSAL_TEMPLATE_ID,
        }

    @classmethod
    def advice_type_to_decision(cls, advice_type):
        return cls.decision_map[advice_type]

    @classmethod
    def get_template(cls, decision):
        return cls.templates()[decision]


def get_decision_made_at(apps, decision, case):
    documents = case.casedocument_set.filter(
        generatedcasedocument__template_id=LicenceDecisionType.get_template(decision),
        safe=True,
        visible_to_exporter=True,
    )
    return documents.earliest("created_at").created_at


@transaction.atomic
def populate_licence_decisions(apps, schema_editor):
    Audit = apps.get_model("audit_trail", "Audit")
    GeneratedCaseDocument = apps.get_model("generated_documents", "GeneratedCaseDocument")
    LicenceDecision = apps.get_model("cases", "LicenceDecision")

    # We want to keep track of all the licence decisions so we don't create duplicates.
    licence_decisions = {}

    # We first try to identify all of the issued and refused licences using the final recommendation audit log.
    # We order by created_at as we want the first of these for any given application.
    created_final_recommendations = Audit.objects.filter(verb=AuditType.CREATED_FINAL_RECOMMENDATION).order_by(
        "created_at"
    )
    for audit_log in created_final_recommendations:
        advice_type = audit_log.payload["decision"]
        if advice_type not in [AdviceType.APPROVE, AdviceType.REFUSE]:
            continue

        case_id = audit_log.target_object_id
        decision = LicenceDecisionType.advice_type_to_decision(advice_type)

        # If we've seen this before then we know we already have the first decision of this type for this case.
        found_decision = (str(case_id), decision)
        if found_decision in licence_decisions:
            continue

        licence_decisions[found_decision] = LicenceDecision(
            case_id=audit_log.target_object_id,
            created_at=audit_log.created_at,
            decision=decision,
        )

    # We now fallback to a slightly different heuristic that is less accurate as there were cases created before
    # the final recommendation audit log was generated so the point in time the case document was generated is the
    # next best event we can use.
    generated_case_documents = GeneratedCaseDocument.objects.filter(
        case__status__status__in=[*CaseStatusEnum.terminal_statuses(), CaseStatusEnum.REOPENED_DUE_TO_ORG_CHANGES],
        template_id__in=[SIEL_LICENCE_TEMPLATE_ID, SIEL_REFUSAL_TEMPLATE_ID],
        advice_type__in=[AdviceType.APPROVE, AdviceType.REFUSE],
        visible_to_exporter=True,
        safe=True,
    ).annotate(
        decision=DBCase(
            When(template_id=SIEL_LICENCE_TEMPLATE_ID, then=Value(LicenceDecisionType.ISSUED)),
            When(template_id=SIEL_REFUSAL_TEMPLATE_ID, then=Value(LicenceDecisionType.REFUSED)),
        ),
    )
    for case_document in generated_case_documents:
        decision_to_find = (str(case_document.case_id), case_document.decision)
        found_decision = licence_decisions.get(decision_to_find)
        if found_decision:
            # If we have already seen this decision before then that means we can probably skip it but we want to
            # double check the difference in our generated document timestamp and the audit log.
            # This is to solve an annoying edge case where a decision was made before and after the final recommendation
            # audit log existed.
            # In this case there will be a much later audit log than the original point in time the case document was
            # generated.
            # Given these cases (and a timedelta of 3 days lets us find them) we should set the date to the generated
            # document timestamp.
            decision_made_at = get_decision_made_at(apps, case_document.decision, case_document.case)
            if (found_decision.created_at - decision_made_at) > datetime.timedelta(days=3):
                found_decision.created_at = decision_made_at
            continue
        licence_decisions[decision_to_find] = LicenceDecision(
            case_id=case_document.case_id,
            created_at=case_document.created_at,
            decision=case_document.decision,
        )

    LicenceDecision.objects.bulk_create(licence_decisions.values())


class Migration(migrations.Migration):

    dependencies = [
        ("cases", "0067_licencedecision"),
        ("generated_documents", "0002_alter_generatedcasedocument_advice_type"),
    ]

    operations = [
        migrations.RunPython(
            populate_licence_decisions,
            migrations.RunPython.noop,
        ),
    ]
