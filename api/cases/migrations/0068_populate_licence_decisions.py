# Generated by Django 4.2.16 on 2024-10-31 12:43
import functools
import operator

from django.contrib.postgres.aggregates import ArrayAgg
from django.db import migrations, transaction
from django.db.models import Case as DBCase, Q, TextField, Value, When
from django.db.models.functions import Cast

from api.audit_trail.enums import AuditType
from api.cases.enums import AdviceType, LicenceDecisionType
from api.licences.enums import LicenceStatus


@transaction.atomic
def populate_licence_decisions(apps, schema_editor):
    Audit = apps.get_model("audit_trail", "Audit")
    GeneratedCaseDocument = apps.get_model("generated_documents", "GeneratedCaseDocument")
    LicenceDecision = apps.get_model("cases", "LicenceDecision")

    licence_decisions = []

    final_decision_qs = Audit.objects.filter(verb=AuditType.CREATED_FINAL_RECOMMENDATION).order_by("-created_at")
    earliest_audit_log = final_decision_qs.last()

    document_qs = (
        GeneratedCaseDocument.objects.filter(
            created_at__date__lt=earliest_audit_log.created_at.date(),
            template_id__in=LicenceDecisionType.templates().values(),
            advice_type__in=[AdviceType.APPROVE, AdviceType.REFUSE],
            visible_to_exporter=True,
            safe=True,
        )
        .annotate(template_ids=ArrayAgg(Cast("template_id", output_field=TextField()), distinct=True))
        .filter(
            functools.reduce(
                operator.or_,
                [Q(template_ids=[template_id]) for template_id in LicenceDecisionType.templates().values()],
            )
        )
        .annotate(
            decision=DBCase(
                *[
                    When(template_ids=[template_id], then=Value(decision))
                    for decision, template_id in LicenceDecisionType.templates().items()
                ]
            )
        )
    )

    for audit_log in final_decision_qs:
        advice_type = audit_log.payload["decision"]
        if advice_type not in [AdviceType.APPROVE, AdviceType.REFUSE]:
            continue

        decision = LicenceDecisionType.advice_type_to_decision(advice_type)
        licence_decisions.append(
            LicenceDecision(
                case_id=str(audit_log.target_object_id),
                decision=decision,
                created_at=audit_log.created_at,
            )
        )

    for document in document_qs:
        licence_decisions.append(
            LicenceDecision(
                case_id=str(document.case_id),
                decision=document.decision,
                created_at=document.created_at,
            )
        )

    # Revoked cases
    revoked_audit_qs = Audit.objects.filter(
        payload__status=LicenceStatus.REVOKED,
        verb=AuditType.LICENCE_UPDATED_STATUS,
    )

    for audit_log in revoked_audit_qs:
        case_id = audit_log.target_object_id
        licence_decisions.append(
            LicenceDecision(
                case_id=case_id,
                decision=LicenceDecisionType.REVOKED,
                created_at=audit_log.created_at,
            )
        )

    LicenceDecision.objects.bulk_create(licence_decisions)


class Migration(migrations.Migration):

    dependencies = [
        ("cases", "0067_licencedecision"),
    ]

    operations = [
        migrations.RunPython(
            populate_licence_decisions,
            migrations.RunPython.noop,
        ),
    ]
