# Generated by Django 4.2.16 on 2024-10-31 12:43
import functools
import operator

from django.contrib.postgres.aggregates import ArrayAgg
from django.db import migrations, transaction
from django.db.models import Case as DBCase, Q, TextField, Value, When
from django.db.models.functions import Cast

from api.audit_trail.enums import AuditType
from api.cases.enums import AdviceType, LicenceDecisionType
from api.licences.enums import LicenceStatus


@transaction.atomic
def populate_licence_decisions(apps, schema_editor):
    """
    To back populate licence decision we primarily take the timestamp of CREATED_FINAL_RECOMMENDATION audit log
    as the decision date. This is emitted when the case is finalised and all decision documents are published
    to Exporter so this is the accurate decision date.
    However this event is introduced at a later point of time and not available for cases. In these cases
    we fallback to using the document generation date as the decision date. Usually these two steps happen
    without much time difference (generating documents and publishing them) so it is a reliable approximation.
    We also observed that only few cases differ and maximum variation is ~3days which doesn't affect reports.
    """

    Audit = apps.get_model("audit_trail", "Audit")
    GeneratedCaseDocument = apps.get_model("generated_documents", "GeneratedCaseDocument")
    LicenceDecision = apps.get_model("cases", "LicenceDecision")

    licence_decisions = []

    final_decision_qs = Audit.objects.filter(verb=AuditType.CREATED_FINAL_RECOMMENDATION).order_by("-created_at")

    document_qs = (
        GeneratedCaseDocument.objects.filter(
            template_id__in=LicenceDecisionType.templates().values(),
            advice_type__in=[AdviceType.APPROVE, AdviceType.REFUSE],
            visible_to_exporter=True,
            safe=True,
        )
        .annotate(template_ids=ArrayAgg(Cast("template_id", output_field=TextField()), distinct=True))
        .filter(
            functools.reduce(
                operator.or_,
                [Q(template_ids=[template_id]) for template_id in LicenceDecisionType.templates().values()],
            )
        )
        .annotate(
            decision=DBCase(
                *[
                    When(template_ids=[template_id], then=Value(decision))
                    for decision, template_id in LicenceDecisionType.templates().items()
                ]
            )
        )
    )

    # When running tests audit entries are not available so filtering documents
    # the audit log created date earlier fails
    if final_decision_qs:
        earliest_audit_log = final_decision_qs.last()
        document_qs = document_qs.filter(
            created_at__date__lt=earliest_audit_log.created_at.date(),
        )

    for audit_log in final_decision_qs:
        advice_type = audit_log.payload["decision"]
        if advice_type not in [AdviceType.APPROVE, AdviceType.REFUSE]:
            continue

        decision = LicenceDecisionType.advice_type_to_decision(advice_type)
        licence_decisions.append(
            LicenceDecision(
                case_id=str(audit_log.target_object_id),
                decision=decision,
                created_at=audit_log.created_at,
            )
        )

    for document in document_qs:
        licence_decisions.append(
            LicenceDecision(
                case_id=str(document.case_id),
                decision=document.decision,
                created_at=document.created_at,
            )
        )

    # Revoked cases
    revoked_audit_qs = Audit.objects.filter(
        payload__status=LicenceStatus.REVOKED,
        verb=AuditType.LICENCE_UPDATED_STATUS,
    )

    for audit_log in revoked_audit_qs:
        case_id = audit_log.target_object_id
        licence_decisions.append(
            LicenceDecision(
                case_id=case_id,
                decision=LicenceDecisionType.REVOKED,
                created_at=audit_log.created_at,
            )
        )

    LicenceDecision.objects.bulk_create(licence_decisions)


class Migration(migrations.Migration):

    dependencies = [
        ("cases", "0067_licencedecision"),
        ("generated_documents", "0002_alter_generatedcasedocument_advice_type"),
    ]

    operations = [
        migrations.RunPython(
            populate_licence_decisions,
            migrations.RunPython.noop,
        ),
    ]
