# Generated by Django 4.2.16 on 2024-11-13 17:19
import functools
import operator

from django.contrib.postgres.aggregates import ArrayAgg
from django.db import migrations, transaction
from django.db.models import Case as DBCase, Q, TextField, Value, When
from django.db.models.functions import Cast

from api.audit_trail.enums import AuditType
from api.cases.enums import AdviceType, LicenceDecisionType


@transaction.atomic
def attach_licence_to_licence_decisions(apps, schema_editor):
    LicenceDecision = apps.get_model("cases", "LicenceDecision")

    Audit = apps.get_model("audit_trail", "Audit")
    GeneratedCaseDocument = apps.get_model("generated_documents", "GeneratedCaseDocument")
    LicenceDecision = apps.get_model("cases", "LicenceDecision")
    Licence = apps.get_model("licences", "Licence")

    licence_decisions_to_update = []

    final_decision_qs = Audit.objects.filter(verb=AuditType.CREATED_FINAL_RECOMMENDATION).order_by("-created_at")

    document_qs = (
        GeneratedCaseDocument.objects.filter(
            template_id__in=LicenceDecisionType.templates().values(),
            advice_type=AdviceType.APPROVE,
            visible_to_exporter=True,
            safe=True,
        )
        .annotate(template_ids=ArrayAgg(Cast("template_id", output_field=TextField()), distinct=True))
        .filter(
            functools.reduce(
                operator.or_,
                [Q(template_ids=[template_id]) for template_id in LicenceDecisionType.templates().values()],
            )
        )
        .annotate(
            decision=DBCase(
                *[
                    When(template_ids=[template_id], then=Value(decision))
                    for decision, template_id in LicenceDecisionType.templates().items()
                ]
            )
        )
    )

    # When running tests audit entries are not available so filtering documents
    # the audit log created date earlier fails
    if final_decision_qs:
        earliest_audit_log = final_decision_qs.last()
        document_qs = document_qs.filter(
            created_at__date__lt=earliest_audit_log.created_at.date(),
        )

    for audit_log in final_decision_qs:
        advice_type = audit_log.payload["decision"]
        if advice_type != AdviceType.APPROVE:
            continue

        decision = LicenceDecisionType.advice_type_to_decision(advice_type)
        obj = LicenceDecision.objects.get(
            case_id=str(audit_log.target_object_id),
            decision=decision,
            created_at=audit_log.created_at,
        )
        obj.licence = Licence.objects.get(reference_code=audit_log.payload["licence_reference"])
        licence_decisions_to_update.append(obj)

    for document in document_qs:
        obj = LicenceDecision.objects.get(
            case_id=str(document.case_id),
            decision=document.decision,
            created_at=document.created_at,
        )
        obj.licence = document.licence
        licence_decisions_to_update.append(obj)

    LicenceDecision.objects.bulk_update(licence_decisions_to_update, ["licence"])


class Migration(migrations.Migration):

    dependencies = [
        ("cases", "0069_licencedecision_excluded_from_statistics_reason"),
    ]

    operations = [
        migrations.RunPython(
            attach_licence_to_licence_decisions,
            migrations.RunPython.noop,
        ),
    ]
